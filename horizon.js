// Generated by CoffeeScript 1.6.3
(function() {
  var utils,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.HorizonGenerator = {};

  utils = {};

  Math.clamp = function(value, min, max) {
    if (min > value) {
      return min;
    } else if (max < value) {
      return max;
    } else {
      return value;
    }
  };

  window.HorizonHook = (function() {
    function HorizonHook(min, max, lambda, easing) {
      this.min = min;
      this.max = max;
      this.lambda = lambda;
      this.easing = easing;
      this.edges_state = 0;
      this.offset = 0;
      if (this.easing != null) {
        if (typeof this.easing === "string") {
          this.easing = jQuery.easing[this.easing];
        }
      }
    }

    HorizonHook.prototype.repr = function() {
      return "HorizonHook " + this.min + "-" + this.max + ", offset " + this.offset + " (" + (this.get_offset_frac()) + "/1), edges-state " + this.edges_state;
    };

    HorizonHook.prototype.invoke = function() {
      if (Horizon.VERBOSE) {
        console.log("Invoking: " + (this.repr()));
      }
      if (this.easing != null) {
        if (Horizon.VERBOSE) {
          console.log("(Raw: " + (this.get_offset_frac()) + ", with easing: " + (this.easing(this.get_offset_frac(), this.offset, this.min, this.max, this.get_range())) + ")");
        }
        return this.lambda.call(this, this.easing(this.get_offset_frac(), this.offset, this.min, this.max, this.get_range()), this.offset);
      } else {
        return this.lambda.call(this, this.get_offset_frac(), this.offset);
      }
    };

    HorizonHook.prototype.get_range = function() {
      return this.max - this.min;
    };

    HorizonHook.prototype.get_offset_pct = function() {
      return this.get_offset_frac * 100;
    };

    HorizonHook.prototype.get_offset_frac = function() {
      return this.offset * 1.0 / (this.max * 1.0 - this.min);
    };

    HorizonHook.prototype.should_fire = function(absolute_offset, force_fire) {
      var _ref;
      if (absolute_offset == null) {
        absolute_offset = this.offset;
      }
      if (force_fire == null) {
        force_fire = false;
      }
      this.offset = Math.clamp(absolute_offset, this.min, this.max) - this.min;
      if (Horizon.VERBOSE) {
        console.log("Current offset: abs " + absolute_offset + ", rel " + this.offset);
      }
      if ((0 < (_ref = this.offset) && _ref < this.get_range())) {
        this.edges_state = 0;
        if (Horizon.VERBOSE) {
          console.log("Offset falls within boundaries.");
        }
        return true;
      }
      if ((this.edges_state === -1 && this.offset === 0) || (this.edges_state === 1 && this.offset === this.get_range())) {
        if (Horizon.VERBOSE) {
          console.log("Should not run. Edge state: " + this.edges_state);
        }
        return false;
      }
      if (this.offset === 0) {
        if (this.edges_state === -1) {
          return false;
        } else {
          this.edges_state = -1;
          if (Horizon.VERBOSE) {
            console.log("Minning.");
          }
          return true;
        }
      } else if (this.offset === this.get_range()) {
        if (this.edges_state === 1) {
          return false;
        } else {
          this.edges_state = 1;
          if (Horizon.VERBOSE) {
            console.log("Maxing.");
          }
          return true;
        }
      } else {
        this.edges_state = 0;
      }
      return false;
    };

    return HorizonHook;

  })();

  window.Horizon = (function() {
    function Horizon(window, skip_bind) {
      var _this = this;
      this.window = window;
      if (skip_bind == null) {
        skip_bind = false;
      }
      this.hooks = [];
      if (typeof this.window === "function") {
        if (Horizon.VERBOSE) {
          console.log("Got function for @window.");
        }
        this.get_offset = function() {
          return this.window();
        };
      } else {
        this.get_offset = function() {
          return jQuery(_this.window).scrollTop();
        };
        if (!skip_bind) {
          jQuery(this.window).scroll(function() {
            return _this.refresh();
          });
        }
      }
    }

    Horizon.prototype.register_hook = function(hook) {
      return this.hooks.push(hook);
    };

    Horizon.prototype.init_hook = function(hook) {
      if (hook.should_fire(this.get_offset())) {
        hook.invoke();
      }
      return hook.initialized = true;
    };

    Horizon.prototype.new_hook = function(min, max, lambda) {
      return this.register_hook(new HorizonHook(min, max, lambda));
    };

    Horizon.prototype.refresh = function(offset) {
      var hook, _i, _len, _ref, _results;
      if (offset == null) {
        offset = this.get_offset();
      }
      if (Horizon.VERBOSE) {
        console.log("offset: " + offset);
      }
      this.sort_hooks(offset);
      _ref = this.hooks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hook = _ref[_i];
        if (hook.should_fire(offset)) {
          _results.push(hook.invoke());
        }
      }
      return _results;
    };

    Horizon.prototype.prepare_hooks = function(offset) {
      var hook, hook_list, _i, _len;
      if (offset == null) {
        offset = this.get_offset();
      }
      hook_list = this.sort_hooks(offset);
      for (_i = 0, _len = hook_list.length; _i < _len; _i++) {
        hook = hook_list[_i];
        if (!hook.initialized) {
          this.init_hook(hook);
        }
      }
      if (Horizon.VERBOSE) {
        return console.log("Done preparing hooks.");
      }
    };

    Horizon.prototype.sort_hooks = function(offset) {
      var hook, hook_list, hooks_after, hooks_before;
      hooks_before = (function() {
        var _i, _len, _ref, _results;
        _ref = this.hooks;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          hook = _ref[_i];
          if (hook.max < offset) {
            _results.push(hook);
          }
        }
        return _results;
      }).call(this);
      hooks_before.sort(function(a, b) {
        return a.max - b.max;
      });
      hooks_after = (function() {
        var _i, _len, _ref, _results;
        _ref = this.hooks;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          hook = _ref[_i];
          if ((hook.min >= offset) && (__indexOf.call(hooks_before, hook) < 0)) {
            _results.push(hook);
          }
        }
        return _results;
      }).call(this);
      hooks_after.sort(function(a, b) {
        return b.min - a.min;
      });
      hook_list = hooks_before.concat(hooks_after);
      if (Horizon.VERBOSE) {
        console.log(hook_list);
      }
      return hook_list;
    };

    return Horizon;

  })();

  utils.interpolate_css = function(start, end, frac) {
    var curval, end_parts, mode, parts, res, scale;
    if (typeof start === "string") {
      start = start.toLowerCase();
      end = end.toLowerCase();
      if ((start[0] === "#") || (start.slice(0, 3) === "rgb")) {
        mode = "color";
      } else {
        mode = "str_value";
      }
    } else {
      mode = "int_value";
    }
    switch (mode) {
      case "str_value":
        parts = start.split(/^([+-\d\.]+)([A-Za-z]+)/);
        if (parts.length === 1) {
          start = parseFloat(start);
        } else {
          scale = parts[2];
          start = parseFloat(parts[1]);
        }
        end_parts = end.split(/^([+|-|\d|\.]+)([A-Za-z]+)/);
        if (end_parts.length === 1) {
          end = parseFloat(end);
        } else {
          end = parseFloat(end_parts[1]);
        }
        res = start + ((end - start) * frac);
        return res.toString() + scale;
      case "color":
        if (!Horizon.HSV_mode) {
          if (Horizon.VERBOSE) {
            console.log("Interpolating color (" + start + "->" + end + ")");
          }
          start = utils.convert_to_rgba(start);
          end = utils.convert_to_rgba(end);
          curval = start.map(function(el, i) {
            return utils.interpolate_css(el, end[i], frac);
          });
          if (Horizon.VERBOSE) {
            console.log(curval);
          }
          if (Horizon.VERBOSE) {
            console.log("Interpolating color (" + start + "->" + end + ")");
          }
          return utils.rgba_to_css(curval);
        } else {
          if (Horizon.VERBOSE) {
            console.log("Interpolating color (" + start + "->" + end + ") via HSV");
          }
          start = utils.convert_to_hsva(start);
          end = utils.convert_to_hsva(end);
          curval = [utils.interpolate_hue(start[0], end[0], frac)].concat(start.slice(1).map(function(el, i) {
            return utils.interpolate_css(el, end[i + 1], frac);
          }));
          if (Horizon.VERBOSE) {
            console.log(curval);
          }
          if (Horizon.VERBOSE) {
            console.log("Interpolating color (" + start + "->" + end + ") via HSV");
          }
          return utils.hsva_to_css(curval);
        }
        break;
      case "int_value":
        return start + ((end - start) * frac);
    }
  };

  utils.interpolate_hue = function(start, end, frac) {
    var distance_neg, distance_pos, posend;
    distance_neg = Math.abs(end - start);
    distance_pos = Math.abs((posend = (end < frac ? end + 360 : end - 360)) - start);
    if (distance_neg <= distance_pos) {
      return utils.interpolate_css(start, end, frac);
    } else {
      return utils.interpolate_css(start, end + posend, frac);
    }
  };

  utils.lambda_for_css_property = function(element, property, params) {
    return function(offset_frac, offset_rel) {
      if (Horizon.VERBOSE) {
        console.log("Changing CSS property " + property + " to 			" + (utils.interpolate_css(params.start, params.end, offset_frac)));
      }
      return element.css(property, utils.interpolate_css(params.start, params.end, offset_frac));
    };
  };

  utils.convert_to_rgba = function(csscolor) {
    var a, atmp, b, color, g, mode, r, _ref;
    csscolor = csscolor.toLowerCase();
    mode = "classic";
    if (csscolor.slice(0, 3) === "rgb") {
      mode = "rgb";
    }
    r = 0;
    g = 0;
    b = 0;
    a = 1;
    switch (mode) {
      case "classic":
        if (csscolor.length === 4) {
          r = parseInt(csscolor[1] + csscolor[1], 16);
          g = parseInt(csscolor[2] + csscolor[2], 16);
          b = parseInt(csscolor[3] + csscolor[3], 16);
        } else if (csscolor.length === 7) {
          r = parseInt(csscolor.slice(1, 3), 16);
          g = parseInt(csscolor.slice(3, 5), 16);
          b = parseInt(csscolor.slice(5, 7), 16);
        }
        break;
      case "rgb":
        _ref = (function() {
          var _i, _len, _ref, _results;
          _ref = csscolor.match(/([0-9]+)/g);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            color = _ref[_i];
            _results.push(parseInt(color));
          }
          return _results;
        })(), r = _ref[0], g = _ref[1], b = _ref[2], atmp = _ref[3];
        if (atmp != null) {
          a = atmp;
        }
    }
    return [r, g, b, a];
  };

  utils.convert_to_hsva = function(csscolor) {
    var chroma, color, hue, saturation, value;
    color = utils.convert_to_rgba(csscolor);
    if (Horizon.VERBOSE) {
      console.log("Colour " + csscolor + " was converted into array: " + color);
    }
    color = (color.slice(0, 3).map(function(el, i) {
      return el / 255.0;
    })).concat(color[3]);
    if (Horizon.VERBOSE) {
      console.log("And its array is now: " + color);
    }
    value = Math.max.apply(Math, color.slice(0, 3));
    chroma = value - (Math.min.apply(Math, color.slice(0, 3)));
    hue = 0;
    if (value === color[0]) {
      hue = (1.0 * (color[1] - color[2]) / chroma + 6) % 6;
    } else if (value === color[1]) {
      hue = 1.0 * (color[2] - color[0]) / chroma + 2;
    } else if (value === color[2]) {
      hue = 1.0 * (color[0] - color[1]) / chroma + 4;
    }
    hue *= 60;
    saturation = chroma === 0 ? 0 : 1.0 * chroma / value;
    return [hue, saturation, value, color[3]];
  };

  utils.rgba_to_css = function(r, g, b, a) {
    if (a == null) {
      a = 1;
    }
    if (typeof r === "object") {
      if (Horizon.VERBOSE) {
        console.log("Got an array! Relaunching.");
      }
      return utils.rgba_to_css.apply(utils, r);
    }
    if (Horizon.VERBOSE) {
      console.log("got the following args: " + r + ", " + g + ", " + b);
    }
    return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
  };

  utils.hsva_to_css = function(h, s, v, a) {
    var chroma, color, el, relcolor, relhue, result, x;
    if (a == null) {
      a = 1;
    }
    if (typeof h === "object") {
      if (Horizon.VERBOSE) {
        console.log("Got an array! Relaunching.");
      }
      return utils.hsva_to_css.apply(utils, h);
    }
    if (Horizon.VERBOSE) {
      console.log("hsv got the following args: " + h + ", " + s + ", " + v);
    }
    while (h < 0) {
      h += 360;
    }
    chroma = s * v;
    relhue = (h % 360) / 60.0;
    x = chroma * (1 - Math.abs(relhue % 2 - 1));
    relcolor = [0, 0, 0];
    if ((0 <= relhue && relhue < 1)) {
      relcolor = [chroma, x, 0];
    } else if ((1 <= relhue && relhue < 2)) {
      relcolor = [x, chroma, 0];
    } else if ((2 <= relhue && relhue < 3)) {
      relcolor = [0, chroma, x];
    } else if ((3 <= relhue && relhue < 4)) {
      relcolor = [0, x, chroma];
    } else if ((4 <= relhue && relhue < 5)) {
      relcolor = [x, 0, chroma];
    } else if ((5 <= relhue && relhue < 6)) {
      relcolor = [chroma, 0, x];
    }
    color = ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = relcolor.length; _i < _len; _i++) {
        el = relcolor[_i];
        _results.push(el + v - chroma);
      }
      return _results;
    })()).concat(a);
    result = utils.rgba_to_css((relcolor.map(function(el, i) {
      return Math.floor((el + v - chroma) * 255.0);
    })).concat([a]));
    if (Horizon.VERBOSE) {
      console.log("Got " + result);
    }
    return result;
  };

  window.HorizonGenerator.CSSHook = function(selector, animation, options) {
    var f, hook, lambdas, property, val;
    if (typeof selector === "string") {
      selector = jQuery(selector);
    }
    lambdas = (function() {
      var _results;
      _results = [];
      for (property in animation) {
        val = animation[property];
        _results.push(utils.lambda_for_css_property(selector, property, val));
      }
      return _results;
    })();
    f = function(offset_frac, offset_rel) {
      var l, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = lambdas.length; _i < _len; _i++) {
        l = lambdas[_i];
        _results.push(l.call(this, offset_frac, offset_rel));
      }
      return _results;
    };
    hook = new HorizonHook(options.start, options.start + options.size, f, options.easing);
    return hook;
  };

  window.HorizonGenerator.BinaryHook = function(start, size, lambda_in, lambda_out) {
    var f, hook;
    f = function(offset_frac, offset_rel) {
      if (offset_frac === 0) {
        lambda_in(offset_frac, offset_rel);
      }
      if (offset_frac === 1) {
        return lambda_out(offset_frac, offset_rel);
      }
    };
    hook = new HorizonHook(start, start + size, f);
    return hook;
  };

  window.Horizon.VERBOSE = false;

  window.Horizon.HSV_mode = true;

}).call(this);

/*
//@ sourceMappingURL=horizon.map
*/
